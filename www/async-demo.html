<!-- <script>

  'use strict';



  const outer = () => {

    let t = 2;

    const fn = () => {
      t = 4;
    };

    setTimeout(fn, 2000);

    return () => {
      console.log(t);
    };

  }

  const inner = outer();

  inner();

  setTimeout(() => {
    inner();
  }, 4000);

  // console.dir(inner);


</script> -->


<!-- <script>

  'use strict';

  // pyramid of doom
  setTimeout(() => {
      console.log('a');

      setTimeout(() => {
          console.log('b');

          setTimeout(() => {
              console.log('c');
          }, 500);

      }, 1000);
  
  }, 2000);



</script> -->

<!-- <script>

  'use strict';

  // run the all done function, after all three setTimeout have completed
  // - you may not change the delay values (assume they are random)
  // - you may not wrap the allDone in a setTimeout with value large the
  // other delays
  // - all three setTimeout function calls must invoked in the same task

  const allDone = () => {
    console.log('all done!');
  };

  let t = 0;

  t++;
  setTimeout(() => {
    console.log('a');
    t--;
    if (t === 0) {
      allDone();
    }
  }, 1000);

  t++;
  setTimeout(() => {
    console.log('b');
    t--;
    if (t === 0) {
      allDone();
    }
  }, 2000);

  t++;
  setTimeout(() => {
    console.log('c');
    t--;
    if (t === 0) {
      allDone();
    }
  }, 500);
  
</script> -->





<script>

  'use strict';


  /*
  class Promise {

    constructor(fn) {

      this.resolveFns = [];
      this.rejectFns = [];

      const resolveFn = (data) => {
        this.resolveFns.forEach(resolveFn => resolveFn(data));
      }

      const rejectFn = (data) => {
        this.rejectFns.forEach(rejectFn => rejectFn(data));
      }

      fn(resolveFn, rejectFn);
    }

    then(fn) {
      this.resolveFns.push(fn);
    }
    catch(fn) {
      this.rejectFns.push(fn);
    }
  }
  */
  /*
  console.log('young man poses the question');

  const youngMan = new Promise(function youngLady(resolve, reject) {
    
    console.log('young lady is diligently considering his request...');
    
    setTimeout(function sheDecides() {
      console.log('she says yes to the dress but with young man\'s best friend');
      reject('no, she fell in love with his best friend');
    }, 2000);
  
  });

  youngMan
    .then(function heIsHappy(result) {
      console.log(result);
      console.log('yay! I am getting married!');
    })
    .catch(function heIsNotHappy(result) {
      console.log(result);
      console.log('time to find a new friend...');
    });

  console.log('young man is waiting...');
  */

  const xhr = new XMLHttpRequest();

  xhr.addEventListener('readystatechange', () => {

    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText));
    }

  });

  xhr.open('GET', 'http://localhost:3060/colors');
  xhr.send();

  // create a new function named 'myFetch', the new function should work according to the example below
  // use the XHR example above to make the REST API call

  myFetch('http://localhost:3060/colors').then(colors => console.log(colors));


</script>